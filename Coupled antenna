# -*- coding: utf-8 -*-
"""
Created on Wed Apr 30 10:41:15 2025

@author: mattc
"""
import math
import cmath
from sympy import symbols, I, exp, diff, lambdify
import numpy as np


"All lengths given in units of the wavelength lambda"
l_1 = [0.6, 0.5, 0.45, 0.45, 0.45] #antenna lengths. 
l_2 =[0.001, 0.001, 0.001, 0.001, 0.001] #antenna radii
l_3 = [(0,0), (0.5,0), (1,0), (1.5,0), (2,0)] #antenna position

V = [0, 1, 0, 0, 0] #voltage in each antenna

def G(p, q, k, z, z_1, L_1, L_2, L_3):
   
    """

    Parameters
    ----------
    p, q: antenna indexes
    k : wavenumber
    z : 
    z_1 : z'

    Returns so called impedance kernel
    -------
    """

    #print(L_2)
    if p == q:
        d = L_2[p]
    else:
        d = math.sqrt((L_3[p][0] - L_3[q][0])**2+ (L_3[p][1] - L_3[q][1])**2)
    #print(d)
    R = math.sqrt((z - z_1)**2 + d**2)
    #print(R)
    return (cmath.exp(complex(0, -k*R)))/R

def diff_G(p, q, k, z, z_1, L_1, L_2, L_3):
    
    if p == q:
        d = L_2[p]
    else:
        d = math.sqrt((L_3[p][0] - L_3[q][0])**2+ (L_3[p][1] - L_3[q][1])**2)
        
    R = math.sqrt((z - z_1)**2 + d**2)
    C_1 = 1 + (z-z_1)/R**2 + k**2 * (z - z_1)
    C_2 = ((z - z_1)/R)*cmath.exp(complex(0, -k*R))*(complex(1, k*R))
    return (-R*C_1+2*(z-z_1)*C_2)/R**4


def Z(p, q, k):
    """
    Compute the coefficient of entry (p, q) of the impedance matrix

    """
    global L_1, L_2, L_3
    wavelength = 2*math.pi/k
    L_1 = [l*wavelength for l in l_1]
    L_2 = [l*wavelength for l in l_2]
    L_3 = [(x*wavelength, y*wavelength) for (x, y) in l_3]
    h_p = L_1[p]/2
    h_q = L_1[q]/2
    N = 100 #even number
    Z = 0
    eta = 376.7 #sqrt(mu_0/epsilon_0)
    
    for n in range(-N//2, N//2+1):
        z = (n*h_p)/N
        dz = h_p/N
        for m in range(-N//2, N//2+1):
              z_1 = (m*h_q)/N
              dz_1 = h_q/N
              g = G(p, q, k, z, z_1, L_1, L_2, L_3)
              g_sec = diff_G(p, q, k, z, z_1, L_1, L_2, L_3)
                  
              Z += complex(0, eta/(4*math.pi*k))*math.sin(k*(h_p - abs(z)))**math.sin(k*(h_q - abs(z_1)))*(g*k**2+g_sec)*dz*dz_1
              
    return Z



"""
from sympy import symbols, I, exp, diff, lambdify
import numpy as np

# Define the symbolic variable
z_sym = symbols('z')


# Compute the second derivative symbolically
d2G_dz2 = diff(G, z_sym, 2)

# Convert to a numerical function using lambdify
d2G_dz2_func = lambdify(z_sym, d2G_dz2, modules="numpy")


# Define the wrapper function
def second_derivative_at_z(z_value):
    return d2G_dz2_func(z_value)

"""
   
  



